# 系统调用入门

## 一、实验介绍

在这个实验中，你将学习到系统调用的基本原理以及实验，动手实现一个自己的系统调用，并为它编写相应的测试用例。

## 二、实验目的

1. 掌握系统调用的实现原理
2. 掌握RISC-V架构下系统调用的方式
3. 学会编写系统调用，并能编写相应的用例加以测试

## 三、实验要求

1. 编写实现要求的系统调用
2. 编写相应用户程序进行调用测试
3. 提交代码

## 四、实验步骤

你需要实现的系统调用：`echo(char *str, int len)`，它的功能十分简单：读取字符串并打印出来。

### 1. 系统调用表

在项目的根目录下的`entry`文件夹中打开`syscall.tbl`文件，你会看到如下列表：

![](assets/Pasted%20image%2020230305150331.png)

三列数据分别对应着**系统调用号**，**系统调用名**以及**系统调用接口函数名**。请参照表内已有部分添加你的系统调用，注意你的系统调用号不是强制的，但必需确保是唯一的！（若需要提交，请保证系统调用号为666）

添加完你的系统调用表项后，尝试运行（`./run-qemu.sh`），看看会发生什么？

### 2. 系统调用定义

在上一部分你已经成功添加了你自己的系统调用表项，构建系统将会自动为你生成系统调用的声明等信息，你现在要做的就是要定义你的系统调用。

在这，你可以选择在任意一个已有的`.c`文件中添加你的系统调用定义，如下所示：

```c
uint64_t sys_echo() {
	// ...
}
```

当然，你也可以自己创建一个新的`.c`源文件，在里面编写你自己的函数，但是在你创建完成之后，还需要多做一步：在你新建文件（假设你的文件名为`myecho.c`）的目录下找到对应Makefile，添加一句`obj-y += myecho.o` 。

你可能会注意到，该定义中并没有显示给出系统调用的参数，原因是系统调用的参数传递与普通过程调用参数传递方式不太一致，需要通过*特殊方法*获取。事实上，正常函数参数可以从寄存器或栈中获取，而系统调用的参数则要从陷入时保存的上下文中获取。

> *一些提示*
> 
> 在完成上述工作流程后，你就可以开始编写你的`echo`系统调用，对于系统调用的参数获取问题和返回值问题，你可以参照已有的一些系统调用实现。我们这也附带了一些提示信息来帮助你完成任务：
> 1) 使用`printf`来打印输出，如果遇到函数提示报红，未定义等问题，可以尝试`include "common.h"`来解决。
> 2) 通常情况下，我们返回0表示系统调用成功，否则失败。
> 3) 可以使用`argXXX`系列函数来帮助你获取系统调用的参数，它们被定义在`include/kernel/syscall.h`中。
> 4) 我们无法直接访问用户态传入的指针所指向的内存位置，可以使用`copy_from_user`函数来完成从用户态到内核态的内存拷贝，参见`include/mm/vm.h`。


### 3. 编写测试程序

在`user/src`目录下创建你的测试C程序（例如`test_echo.c`），编写你的测试代码，例如：

```c
#include "string.h"
#include "syscall.h"

// 你的系统调用号
#define SYS_ECHO 666

int main(int argc, char **argv) {
	char *str = "Test String";
    int len = strlen(str);
    syscall(SYS_ECHO, str, len);
    return 0; 
}
```

编写完毕后，在`user/src/init0.c`中执行该用例：

```c
run("test_echo");
```

## 五、思考

1) 在`syscall.tbl`中添加表项生成系统调用声明的原理？
2) 系统调用参数具体是如何获取的？
3) 在RISC-V指令集架构中，如何调用系统调用？